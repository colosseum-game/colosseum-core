// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `effect.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct DamageEffect {
    // message fields
    pub aspect: super::aspect::Aspect,
    pub scaling: ::protobuf::SingularPtrField<super::fraction::Fraction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DamageEffect {
    fn default() -> &'a DamageEffect {
        <DamageEffect as ::protobuf::Message>::default_instance()
    }
}

impl DamageEffect {
    pub fn new() -> DamageEffect {
        ::std::default::Default::default()
    }

    // .Aspect aspect = 1;


    pub fn get_aspect(&self) -> super::aspect::Aspect {
        self.aspect
    }
    pub fn clear_aspect(&mut self) {
        self.aspect = super::aspect::Aspect::ASPECT_NONE;
    }

    // Param is passed by value, moved
    pub fn set_aspect(&mut self, v: super::aspect::Aspect) {
        self.aspect = v;
    }

    // .Fraction scaling = 2;


    pub fn get_scaling(&self) -> &super::fraction::Fraction {
        self.scaling.as_ref().unwrap_or_else(|| <super::fraction::Fraction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scaling(&mut self) {
        self.scaling.clear();
    }

    pub fn has_scaling(&self) -> bool {
        self.scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaling(&mut self, v: super::fraction::Fraction) {
        self.scaling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scaling(&mut self) -> &mut super::fraction::Fraction {
        if self.scaling.is_none() {
            self.scaling.set_default();
        }
        self.scaling.as_mut().unwrap()
    }

    // Take field
    pub fn take_scaling(&mut self) -> super::fraction::Fraction {
        self.scaling.take().unwrap_or_else(|| super::fraction::Fraction::new())
    }
}

impl ::protobuf::Message for DamageEffect {
    fn is_initialized(&self) -> bool {
        for v in &self.scaling {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.aspect, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scaling)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.aspect != super::aspect::Aspect::ASPECT_NONE {
            my_size += ::protobuf::rt::enum_size(1, self.aspect);
        }
        if let Some(ref v) = self.scaling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.aspect != super::aspect::Aspect::ASPECT_NONE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.aspect))?;
        }
        if let Some(ref v) = self.scaling.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DamageEffect {
        DamageEffect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::aspect::Aspect>>(
                "aspect",
                |m: &DamageEffect| { &m.aspect },
                |m: &mut DamageEffect| { &mut m.aspect },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::fraction::Fraction>>(
                "scaling",
                |m: &DamageEffect| { &m.scaling },
                |m: &mut DamageEffect| { &mut m.scaling },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DamageEffect>(
                "DamageEffect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DamageEffect {
        static instance: ::protobuf::rt::LazyV2<DamageEffect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DamageEffect::new)
    }
}

impl ::protobuf::Clear for DamageEffect {
    fn clear(&mut self) {
        self.aspect = super::aspect::Aspect::ASPECT_NONE;
        self.scaling.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DamageEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DamageEffect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DamageOverTimeEffect {
    // message fields
    pub aspect: super::aspect::Aspect,
    pub scaling: ::protobuf::SingularPtrField<super::fraction::Fraction>,
    // message oneof groups
    pub lifetime: ::std::option::Option<DamageOverTimeEffect_oneof_lifetime>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DamageOverTimeEffect {
    fn default() -> &'a DamageOverTimeEffect {
        <DamageOverTimeEffect as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DamageOverTimeEffect_oneof_lifetime {
    lifetime_duration(u32),
}

impl DamageOverTimeEffect {
    pub fn new() -> DamageOverTimeEffect {
        ::std::default::Default::default()
    }

    // .Aspect aspect = 1;


    pub fn get_aspect(&self) -> super::aspect::Aspect {
        self.aspect
    }
    pub fn clear_aspect(&mut self) {
        self.aspect = super::aspect::Aspect::ASPECT_NONE;
    }

    // Param is passed by value, moved
    pub fn set_aspect(&mut self, v: super::aspect::Aspect) {
        self.aspect = v;
    }

    // .Fraction scaling = 2;


    pub fn get_scaling(&self) -> &super::fraction::Fraction {
        self.scaling.as_ref().unwrap_or_else(|| <super::fraction::Fraction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scaling(&mut self) {
        self.scaling.clear();
    }

    pub fn has_scaling(&self) -> bool {
        self.scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaling(&mut self, v: super::fraction::Fraction) {
        self.scaling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scaling(&mut self) -> &mut super::fraction::Fraction {
        if self.scaling.is_none() {
            self.scaling.set_default();
        }
        self.scaling.as_mut().unwrap()
    }

    // Take field
    pub fn take_scaling(&mut self) -> super::fraction::Fraction {
        self.scaling.take().unwrap_or_else(|| super::fraction::Fraction::new())
    }

    // uint32 lifetime_duration = 3;


    pub fn get_lifetime_duration(&self) -> u32 {
        match self.lifetime {
            ::std::option::Option::Some(DamageOverTimeEffect_oneof_lifetime::lifetime_duration(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_lifetime_duration(&mut self) {
        self.lifetime = ::std::option::Option::None;
    }

    pub fn has_lifetime_duration(&self) -> bool {
        match self.lifetime {
            ::std::option::Option::Some(DamageOverTimeEffect_oneof_lifetime::lifetime_duration(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_lifetime_duration(&mut self, v: u32) {
        self.lifetime = ::std::option::Option::Some(DamageOverTimeEffect_oneof_lifetime::lifetime_duration(v))
    }
}

impl ::protobuf::Message for DamageOverTimeEffect {
    fn is_initialized(&self) -> bool {
        for v in &self.scaling {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.aspect, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scaling)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lifetime = ::std::option::Option::Some(DamageOverTimeEffect_oneof_lifetime::lifetime_duration(is.read_uint32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.aspect != super::aspect::Aspect::ASPECT_NONE {
            my_size += ::protobuf::rt::enum_size(1, self.aspect);
        }
        if let Some(ref v) = self.scaling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.lifetime {
            match v {
                &DamageOverTimeEffect_oneof_lifetime::lifetime_duration(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.aspect != super::aspect::Aspect::ASPECT_NONE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.aspect))?;
        }
        if let Some(ref v) = self.scaling.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.lifetime {
            match v {
                &DamageOverTimeEffect_oneof_lifetime::lifetime_duration(v) => {
                    os.write_uint32(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DamageOverTimeEffect {
        DamageOverTimeEffect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::aspect::Aspect>>(
                "aspect",
                |m: &DamageOverTimeEffect| { &m.aspect },
                |m: &mut DamageOverTimeEffect| { &mut m.aspect },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::fraction::Fraction>>(
                "scaling",
                |m: &DamageOverTimeEffect| { &m.scaling },
                |m: &mut DamageOverTimeEffect| { &mut m.scaling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "lifetime_duration",
                DamageOverTimeEffect::has_lifetime_duration,
                DamageOverTimeEffect::get_lifetime_duration,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DamageOverTimeEffect>(
                "DamageOverTimeEffect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DamageOverTimeEffect {
        static instance: ::protobuf::rt::LazyV2<DamageOverTimeEffect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DamageOverTimeEffect::new)
    }
}

impl ::protobuf::Clear for DamageOverTimeEffect {
    fn clear(&mut self) {
        self.aspect = super::aspect::Aspect::ASPECT_NONE;
        self.scaling.clear();
        self.lifetime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DamageOverTimeEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DamageOverTimeEffect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifierEffect {
    // message fields
    pub modifier: ::protobuf::SingularPtrField<super::modifier::Modifier>,
    pub attribute: super::attribute::Attribute,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifierEffect {
    fn default() -> &'a ModifierEffect {
        <ModifierEffect as ::protobuf::Message>::default_instance()
    }
}

impl ModifierEffect {
    pub fn new() -> ModifierEffect {
        ::std::default::Default::default()
    }

    // .Modifier modifier = 1;


    pub fn get_modifier(&self) -> &super::modifier::Modifier {
        self.modifier.as_ref().unwrap_or_else(|| <super::modifier::Modifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modifier(&mut self) {
        self.modifier.clear();
    }

    pub fn has_modifier(&self) -> bool {
        self.modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifier(&mut self, v: super::modifier::Modifier) {
        self.modifier = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifier(&mut self) -> &mut super::modifier::Modifier {
        if self.modifier.is_none() {
            self.modifier.set_default();
        }
        self.modifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifier(&mut self) -> super::modifier::Modifier {
        self.modifier.take().unwrap_or_else(|| super::modifier::Modifier::new())
    }

    // .Attribute attribute = 2;


    pub fn get_attribute(&self) -> super::attribute::Attribute {
        self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute = super::attribute::Attribute::ATTRIBUTE_AGILITY;
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: super::attribute::Attribute) {
        self.attribute = v;
    }
}

impl ::protobuf::Message for ModifierEffect {
    fn is_initialized(&self) -> bool {
        for v in &self.modifier {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifier)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.attribute, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.modifier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.attribute != super::attribute::Attribute::ATTRIBUTE_AGILITY {
            my_size += ::protobuf::rt::enum_size(2, self.attribute);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.modifier.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.attribute != super::attribute::Attribute::ATTRIBUTE_AGILITY {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.attribute))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifierEffect {
        ModifierEffect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::modifier::Modifier>>(
                "modifier",
                |m: &ModifierEffect| { &m.modifier },
                |m: &mut ModifierEffect| { &mut m.modifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::attribute::Attribute>>(
                "attribute",
                |m: &ModifierEffect| { &m.attribute },
                |m: &mut ModifierEffect| { &mut m.attribute },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifierEffect>(
                "ModifierEffect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifierEffect {
        static instance: ::protobuf::rt::LazyV2<ModifierEffect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifierEffect::new)
    }
}

impl ::protobuf::Clear for ModifierEffect {
    fn clear(&mut self) {
        self.modifier.clear();
        self.attribute = super::attribute::Attribute::ATTRIBUTE_AGILITY;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifierEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifierEffect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubEffect {
    // message oneof groups
    pub subeffect: ::std::option::Option<SubEffect_oneof_subeffect>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubEffect {
    fn default() -> &'a SubEffect {
        <SubEffect as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum SubEffect_oneof_subeffect {
    damage_effect(DamageEffect),
    dot_effect(DamageOverTimeEffect),
    modifier_effect(ModifierEffect),
}

impl SubEffect {
    pub fn new() -> SubEffect {
        ::std::default::Default::default()
    }

    // .DamageEffect damage_effect = 1;


    pub fn get_damage_effect(&self) -> &DamageEffect {
        match self.subeffect {
            ::std::option::Option::Some(SubEffect_oneof_subeffect::damage_effect(ref v)) => v,
            _ => <DamageEffect as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_damage_effect(&mut self) {
        self.subeffect = ::std::option::Option::None;
    }

    pub fn has_damage_effect(&self) -> bool {
        match self.subeffect {
            ::std::option::Option::Some(SubEffect_oneof_subeffect::damage_effect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_damage_effect(&mut self, v: DamageEffect) {
        self.subeffect = ::std::option::Option::Some(SubEffect_oneof_subeffect::damage_effect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_damage_effect(&mut self) -> &mut DamageEffect {
        if let ::std::option::Option::Some(SubEffect_oneof_subeffect::damage_effect(_)) = self.subeffect {
        } else {
            self.subeffect = ::std::option::Option::Some(SubEffect_oneof_subeffect::damage_effect(DamageEffect::new()));
        }
        match self.subeffect {
            ::std::option::Option::Some(SubEffect_oneof_subeffect::damage_effect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_damage_effect(&mut self) -> DamageEffect {
        if self.has_damage_effect() {
            match self.subeffect.take() {
                ::std::option::Option::Some(SubEffect_oneof_subeffect::damage_effect(v)) => v,
                _ => panic!(),
            }
        } else {
            DamageEffect::new()
        }
    }

    // .DamageOverTimeEffect dot_effect = 3;


    pub fn get_dot_effect(&self) -> &DamageOverTimeEffect {
        match self.subeffect {
            ::std::option::Option::Some(SubEffect_oneof_subeffect::dot_effect(ref v)) => v,
            _ => <DamageOverTimeEffect as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dot_effect(&mut self) {
        self.subeffect = ::std::option::Option::None;
    }

    pub fn has_dot_effect(&self) -> bool {
        match self.subeffect {
            ::std::option::Option::Some(SubEffect_oneof_subeffect::dot_effect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dot_effect(&mut self, v: DamageOverTimeEffect) {
        self.subeffect = ::std::option::Option::Some(SubEffect_oneof_subeffect::dot_effect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dot_effect(&mut self) -> &mut DamageOverTimeEffect {
        if let ::std::option::Option::Some(SubEffect_oneof_subeffect::dot_effect(_)) = self.subeffect {
        } else {
            self.subeffect = ::std::option::Option::Some(SubEffect_oneof_subeffect::dot_effect(DamageOverTimeEffect::new()));
        }
        match self.subeffect {
            ::std::option::Option::Some(SubEffect_oneof_subeffect::dot_effect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dot_effect(&mut self) -> DamageOverTimeEffect {
        if self.has_dot_effect() {
            match self.subeffect.take() {
                ::std::option::Option::Some(SubEffect_oneof_subeffect::dot_effect(v)) => v,
                _ => panic!(),
            }
        } else {
            DamageOverTimeEffect::new()
        }
    }

    // .ModifierEffect modifier_effect = 2;


    pub fn get_modifier_effect(&self) -> &ModifierEffect {
        match self.subeffect {
            ::std::option::Option::Some(SubEffect_oneof_subeffect::modifier_effect(ref v)) => v,
            _ => <ModifierEffect as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_modifier_effect(&mut self) {
        self.subeffect = ::std::option::Option::None;
    }

    pub fn has_modifier_effect(&self) -> bool {
        match self.subeffect {
            ::std::option::Option::Some(SubEffect_oneof_subeffect::modifier_effect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_modifier_effect(&mut self, v: ModifierEffect) {
        self.subeffect = ::std::option::Option::Some(SubEffect_oneof_subeffect::modifier_effect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_modifier_effect(&mut self) -> &mut ModifierEffect {
        if let ::std::option::Option::Some(SubEffect_oneof_subeffect::modifier_effect(_)) = self.subeffect {
        } else {
            self.subeffect = ::std::option::Option::Some(SubEffect_oneof_subeffect::modifier_effect(ModifierEffect::new()));
        }
        match self.subeffect {
            ::std::option::Option::Some(SubEffect_oneof_subeffect::modifier_effect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_modifier_effect(&mut self) -> ModifierEffect {
        if self.has_modifier_effect() {
            match self.subeffect.take() {
                ::std::option::Option::Some(SubEffect_oneof_subeffect::modifier_effect(v)) => v,
                _ => panic!(),
            }
        } else {
            ModifierEffect::new()
        }
    }
}

impl ::protobuf::Message for SubEffect {
    fn is_initialized(&self) -> bool {
        if let Some(SubEffect_oneof_subeffect::damage_effect(ref v)) = self.subeffect {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SubEffect_oneof_subeffect::dot_effect(ref v)) = self.subeffect {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SubEffect_oneof_subeffect::modifier_effect(ref v)) = self.subeffect {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.subeffect = ::std::option::Option::Some(SubEffect_oneof_subeffect::damage_effect(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.subeffect = ::std::option::Option::Some(SubEffect_oneof_subeffect::dot_effect(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.subeffect = ::std::option::Option::Some(SubEffect_oneof_subeffect::modifier_effect(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.subeffect {
            match v {
                &SubEffect_oneof_subeffect::damage_effect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SubEffect_oneof_subeffect::dot_effect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SubEffect_oneof_subeffect::modifier_effect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.subeffect {
            match v {
                &SubEffect_oneof_subeffect::damage_effect(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SubEffect_oneof_subeffect::dot_effect(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SubEffect_oneof_subeffect::modifier_effect(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubEffect {
        SubEffect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DamageEffect>(
                "damage_effect",
                SubEffect::has_damage_effect,
                SubEffect::get_damage_effect,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DamageOverTimeEffect>(
                "dot_effect",
                SubEffect::has_dot_effect,
                SubEffect::get_dot_effect,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ModifierEffect>(
                "modifier_effect",
                SubEffect::has_modifier_effect,
                SubEffect::get_modifier_effect,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubEffect>(
                "SubEffect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubEffect {
        static instance: ::protobuf::rt::LazyV2<SubEffect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubEffect::new)
    }
}

impl ::protobuf::Clear for SubEffect {
    fn clear(&mut self) {
        self.subeffect = ::std::option::Option::None;
        self.subeffect = ::std::option::Option::None;
        self.subeffect = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubEffect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TargetFlag {
    // message oneof groups
    pub target_flag: ::std::option::Option<TargetFlag_oneof_target_flag>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TargetFlag {
    fn default() -> &'a TargetFlag {
        <TargetFlag as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TargetFlag_oneof_target_flag {
    any(bool),
    gender(super::gender::Gender),
    origin(bool),
}

impl TargetFlag {
    pub fn new() -> TargetFlag {
        ::std::default::Default::default()
    }

    // bool any = 1;


    pub fn get_any(&self) -> bool {
        match self.target_flag {
            ::std::option::Option::Some(TargetFlag_oneof_target_flag::any(v)) => v,
            _ => false,
        }
    }
    pub fn clear_any(&mut self) {
        self.target_flag = ::std::option::Option::None;
    }

    pub fn has_any(&self) -> bool {
        match self.target_flag {
            ::std::option::Option::Some(TargetFlag_oneof_target_flag::any(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_any(&mut self, v: bool) {
        self.target_flag = ::std::option::Option::Some(TargetFlag_oneof_target_flag::any(v))
    }

    // .Gender gender = 2;


    pub fn get_gender(&self) -> super::gender::Gender {
        match self.target_flag {
            ::std::option::Option::Some(TargetFlag_oneof_target_flag::gender(v)) => v,
            _ => super::gender::Gender::GENDER_NONE,
        }
    }
    pub fn clear_gender(&mut self) {
        self.target_flag = ::std::option::Option::None;
    }

    pub fn has_gender(&self) -> bool {
        match self.target_flag {
            ::std::option::Option::Some(TargetFlag_oneof_target_flag::gender(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gender(&mut self, v: super::gender::Gender) {
        self.target_flag = ::std::option::Option::Some(TargetFlag_oneof_target_flag::gender(v))
    }

    // bool origin = 3;


    pub fn get_origin(&self) -> bool {
        match self.target_flag {
            ::std::option::Option::Some(TargetFlag_oneof_target_flag::origin(v)) => v,
            _ => false,
        }
    }
    pub fn clear_origin(&mut self) {
        self.target_flag = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        match self.target_flag {
            ::std::option::Option::Some(TargetFlag_oneof_target_flag::origin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: bool) {
        self.target_flag = ::std::option::Option::Some(TargetFlag_oneof_target_flag::origin(v))
    }
}

impl ::protobuf::Message for TargetFlag {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_flag = ::std::option::Option::Some(TargetFlag_oneof_target_flag::any(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_flag = ::std::option::Option::Some(TargetFlag_oneof_target_flag::gender(is.read_enum()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_flag = ::std::option::Option::Some(TargetFlag_oneof_target_flag::origin(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.target_flag {
            match v {
                &TargetFlag_oneof_target_flag::any(v) => {
                    my_size += 2;
                },
                &TargetFlag_oneof_target_flag::gender(v) => {
                    my_size += ::protobuf::rt::enum_size(2, v);
                },
                &TargetFlag_oneof_target_flag::origin(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.target_flag {
            match v {
                &TargetFlag_oneof_target_flag::any(v) => {
                    os.write_bool(1, v)?;
                },
                &TargetFlag_oneof_target_flag::gender(v) => {
                    os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &TargetFlag_oneof_target_flag::origin(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TargetFlag {
        TargetFlag::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "any",
                TargetFlag::has_any,
                TargetFlag::get_any,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, super::gender::Gender>(
                "gender",
                TargetFlag::has_gender,
                TargetFlag::get_gender,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "origin",
                TargetFlag::has_origin,
                TargetFlag::get_origin,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TargetFlag>(
                "TargetFlag",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TargetFlag {
        static instance: ::protobuf::rt::LazyV2<TargetFlag> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TargetFlag::new)
    }
}

impl ::protobuf::Clear for TargetFlag {
    fn clear(&mut self) {
        self.target_flag = ::std::option::Option::None;
        self.target_flag = ::std::option::Option::None;
        self.target_flag = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TargetFlag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TargetFlag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TargetQuery {
    // message fields
    pub target_flags: ::protobuf::RepeatedField<TargetFlag>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TargetQuery {
    fn default() -> &'a TargetQuery {
        <TargetQuery as ::protobuf::Message>::default_instance()
    }
}

impl TargetQuery {
    pub fn new() -> TargetQuery {
        ::std::default::Default::default()
    }

    // repeated .TargetFlag target_flags = 1;


    pub fn get_target_flags(&self) -> &[TargetFlag] {
        &self.target_flags
    }
    pub fn clear_target_flags(&mut self) {
        self.target_flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_flags(&mut self, v: ::protobuf::RepeatedField<TargetFlag>) {
        self.target_flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_target_flags(&mut self) -> &mut ::protobuf::RepeatedField<TargetFlag> {
        &mut self.target_flags
    }

    // Take field
    pub fn take_target_flags(&mut self) -> ::protobuf::RepeatedField<TargetFlag> {
        ::std::mem::replace(&mut self.target_flags, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TargetQuery {
    fn is_initialized(&self) -> bool {
        for v in &self.target_flags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.target_flags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.target_flags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.target_flags {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TargetQuery {
        TargetQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TargetFlag>>(
                "target_flags",
                |m: &TargetQuery| { &m.target_flags },
                |m: &mut TargetQuery| { &mut m.target_flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TargetQuery>(
                "TargetQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TargetQuery {
        static instance: ::protobuf::rt::LazyV2<TargetQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TargetQuery::new)
    }
}

impl ::protobuf::Clear for TargetQuery {
    fn clear(&mut self) {
        self.target_flags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TargetQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TargetQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TargetingScheme {
    // message oneof groups
    pub targeting_scheme: ::std::option::Option<TargetingScheme_oneof_targeting_scheme>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TargetingScheme {
    fn default() -> &'a TargetingScheme {
        <TargetingScheme as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TargetingScheme_oneof_targeting_scheme {
    all(bool),
    multi_target(u32),
    single_target(bool),
}

impl TargetingScheme {
    pub fn new() -> TargetingScheme {
        ::std::default::Default::default()
    }

    // bool all = 1;


    pub fn get_all(&self) -> bool {
        match self.targeting_scheme {
            ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::all(v)) => v,
            _ => false,
        }
    }
    pub fn clear_all(&mut self) {
        self.targeting_scheme = ::std::option::Option::None;
    }

    pub fn has_all(&self) -> bool {
        match self.targeting_scheme {
            ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::all(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.targeting_scheme = ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::all(v))
    }

    // uint32 multi_target = 2;


    pub fn get_multi_target(&self) -> u32 {
        match self.targeting_scheme {
            ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::multi_target(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_multi_target(&mut self) {
        self.targeting_scheme = ::std::option::Option::None;
    }

    pub fn has_multi_target(&self) -> bool {
        match self.targeting_scheme {
            ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::multi_target(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_target(&mut self, v: u32) {
        self.targeting_scheme = ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::multi_target(v))
    }

    // bool single_target = 3;


    pub fn get_single_target(&self) -> bool {
        match self.targeting_scheme {
            ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::single_target(v)) => v,
            _ => false,
        }
    }
    pub fn clear_single_target(&mut self) {
        self.targeting_scheme = ::std::option::Option::None;
    }

    pub fn has_single_target(&self) -> bool {
        match self.targeting_scheme {
            ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::single_target(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single_target(&mut self, v: bool) {
        self.targeting_scheme = ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::single_target(v))
    }
}

impl ::protobuf::Message for TargetingScheme {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.targeting_scheme = ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::all(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.targeting_scheme = ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::multi_target(is.read_uint32()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.targeting_scheme = ::std::option::Option::Some(TargetingScheme_oneof_targeting_scheme::single_target(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.targeting_scheme {
            match v {
                &TargetingScheme_oneof_targeting_scheme::all(v) => {
                    my_size += 2;
                },
                &TargetingScheme_oneof_targeting_scheme::multi_target(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &TargetingScheme_oneof_targeting_scheme::single_target(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.targeting_scheme {
            match v {
                &TargetingScheme_oneof_targeting_scheme::all(v) => {
                    os.write_bool(1, v)?;
                },
                &TargetingScheme_oneof_targeting_scheme::multi_target(v) => {
                    os.write_uint32(2, v)?;
                },
                &TargetingScheme_oneof_targeting_scheme::single_target(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TargetingScheme {
        TargetingScheme::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "all",
                TargetingScheme::has_all,
                TargetingScheme::get_all,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "multi_target",
                TargetingScheme::has_multi_target,
                TargetingScheme::get_multi_target,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "single_target",
                TargetingScheme::has_single_target,
                TargetingScheme::get_single_target,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TargetingScheme>(
                "TargetingScheme",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TargetingScheme {
        static instance: ::protobuf::rt::LazyV2<TargetingScheme> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TargetingScheme::new)
    }
}

impl ::protobuf::Clear for TargetingScheme {
    fn clear(&mut self) {
        self.targeting_scheme = ::std::option::Option::None;
        self.targeting_scheme = ::std::option::Option::None;
        self.targeting_scheme = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TargetingScheme {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TargetingScheme {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Effect {
    // message fields
    pub sub_effects: ::protobuf::RepeatedField<SubEffect>,
    pub target_queries: ::protobuf::RepeatedField<TargetQuery>,
    pub targeting_scheme: ::protobuf::SingularPtrField<TargetingScheme>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Effect {
    fn default() -> &'a Effect {
        <Effect as ::protobuf::Message>::default_instance()
    }
}

impl Effect {
    pub fn new() -> Effect {
        ::std::default::Default::default()
    }

    // repeated .SubEffect sub_effects = 1;


    pub fn get_sub_effects(&self) -> &[SubEffect] {
        &self.sub_effects
    }
    pub fn clear_sub_effects(&mut self) {
        self.sub_effects.clear();
    }

    // Param is passed by value, moved
    pub fn set_sub_effects(&mut self, v: ::protobuf::RepeatedField<SubEffect>) {
        self.sub_effects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sub_effects(&mut self) -> &mut ::protobuf::RepeatedField<SubEffect> {
        &mut self.sub_effects
    }

    // Take field
    pub fn take_sub_effects(&mut self) -> ::protobuf::RepeatedField<SubEffect> {
        ::std::mem::replace(&mut self.sub_effects, ::protobuf::RepeatedField::new())
    }

    // repeated .TargetQuery target_queries = 2;


    pub fn get_target_queries(&self) -> &[TargetQuery] {
        &self.target_queries
    }
    pub fn clear_target_queries(&mut self) {
        self.target_queries.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_queries(&mut self, v: ::protobuf::RepeatedField<TargetQuery>) {
        self.target_queries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_target_queries(&mut self) -> &mut ::protobuf::RepeatedField<TargetQuery> {
        &mut self.target_queries
    }

    // Take field
    pub fn take_target_queries(&mut self) -> ::protobuf::RepeatedField<TargetQuery> {
        ::std::mem::replace(&mut self.target_queries, ::protobuf::RepeatedField::new())
    }

    // .TargetingScheme targeting_scheme = 3;


    pub fn get_targeting_scheme(&self) -> &TargetingScheme {
        self.targeting_scheme.as_ref().unwrap_or_else(|| <TargetingScheme as ::protobuf::Message>::default_instance())
    }
    pub fn clear_targeting_scheme(&mut self) {
        self.targeting_scheme.clear();
    }

    pub fn has_targeting_scheme(&self) -> bool {
        self.targeting_scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targeting_scheme(&mut self, v: TargetingScheme) {
        self.targeting_scheme = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targeting_scheme(&mut self) -> &mut TargetingScheme {
        if self.targeting_scheme.is_none() {
            self.targeting_scheme.set_default();
        }
        self.targeting_scheme.as_mut().unwrap()
    }

    // Take field
    pub fn take_targeting_scheme(&mut self) -> TargetingScheme {
        self.targeting_scheme.take().unwrap_or_else(|| TargetingScheme::new())
    }
}

impl ::protobuf::Message for Effect {
    fn is_initialized(&self) -> bool {
        for v in &self.sub_effects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.target_queries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.targeting_scheme {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sub_effects)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.target_queries)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.targeting_scheme)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sub_effects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.target_queries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.targeting_scheme.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sub_effects {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.target_queries {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.targeting_scheme.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Effect {
        Effect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubEffect>>(
                "sub_effects",
                |m: &Effect| { &m.sub_effects },
                |m: &mut Effect| { &mut m.sub_effects },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TargetQuery>>(
                "target_queries",
                |m: &Effect| { &m.target_queries },
                |m: &mut Effect| { &mut m.target_queries },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TargetingScheme>>(
                "targeting_scheme",
                |m: &Effect| { &m.targeting_scheme },
                |m: &mut Effect| { &mut m.targeting_scheme },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Effect>(
                "Effect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Effect {
        static instance: ::protobuf::rt::LazyV2<Effect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Effect::new)
    }
}

impl ::protobuf::Clear for Effect {
    fn clear(&mut self) {
        self.sub_effects.clear();
        self.target_queries.clear();
        self.targeting_scheme.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Effect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Effect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ceffect.proto\x1a\x0caspect.proto\x1a\x0fattribute.proto\x1a\x0efra\
    ction.proto\x1a\x0cgender.proto\x1a\x0emodifier.proto\"T\n\x0cDamageEffe\
    ct\x12\x1f\n\x06aspect\x18\x01\x20\x01(\x0e2\x07.AspectR\x06aspect\x12#\
    \n\x07scaling\x18\x02\x20\x01(\x0b2\t.FractionR\x07scaling\"\x97\x01\n\
    \x14DamageOverTimeEffect\x12\x1f\n\x06aspect\x18\x01\x20\x01(\x0e2\x07.A\
    spectR\x06aspect\x12#\n\x07scaling\x18\x02\x20\x01(\x0b2\t.FractionR\x07\
    scaling\x12-\n\x11lifetime_duration\x18\x03\x20\x01(\rH\0R\x10lifetimeDu\
    rationB\n\n\x08lifetime\"a\n\x0eModifierEffect\x12%\n\x08modifier\x18\
    \x01\x20\x01(\x0b2\t.ModifierR\x08modifier\x12(\n\tattribute\x18\x02\x20\
    \x01(\x0e2\n.AttributeR\tattribute\"\xc2\x01\n\tSubEffect\x124\n\rdamage\
    _effect\x18\x01\x20\x01(\x0b2\r.DamageEffectH\0R\x0cdamageEffect\x126\n\
    \ndot_effect\x18\x03\x20\x01(\x0b2\x15.DamageOverTimeEffectH\0R\tdotEffe\
    ct\x12:\n\x0fmodifier_effect\x18\x02\x20\x01(\x0b2\x0f.ModifierEffectH\0\
    R\x0emodifierEffectB\x0b\n\tsubeffect\"l\n\nTargetFlag\x12\x12\n\x03any\
    \x18\x01\x20\x01(\x08H\0R\x03any\x12!\n\x06gender\x18\x02\x20\x01(\x0e2\
    \x07.GenderH\0R\x06gender\x12\x18\n\x06origin\x18\x03\x20\x01(\x08H\0R\
    \x06originB\r\n\x0btarget_flag\"=\n\x0bTargetQuery\x12.\n\x0ctarget_flag\
    s\x18\x01\x20\x03(\x0b2\x0b.TargetFlagR\x0btargetFlags\"\x85\x01\n\x0fTa\
    rgetingScheme\x12\x12\n\x03all\x18\x01\x20\x01(\x08H\0R\x03all\x12#\n\
    \x0cmulti_target\x18\x02\x20\x01(\rH\0R\x0bmultiTarget\x12%\n\rsingle_ta\
    rget\x18\x03\x20\x01(\x08H\0R\x0csingleTargetB\x12\n\x10targeting_scheme\
    \"\xa7\x01\n\x06Effect\x12+\n\x0bsub_effects\x18\x01\x20\x03(\x0b2\n.Sub\
    EffectR\nsubEffects\x123\n\x0etarget_queries\x18\x02\x20\x03(\x0b2\x0c.T\
    argetQueryR\rtargetQueries\x12;\n\x10targeting_scheme\x18\x03\x20\x01(\
    \x0b2\x10.TargetingSchemeR\x0ftargetingSchemeb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
