// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.14.0
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `effect.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct DamageEffect {
    // message fields
    pub aspect: ::protobuf::ProtobufEnumOrUnknown<super::aspect::Aspect>,
    pub scaling: ::protobuf::MessageField<super::fraction::Fraction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a DamageEffect {
    fn default() -> &'a DamageEffect {
        <DamageEffect as ::protobuf::Message>::default_instance()
    }
}

impl DamageEffect {
    pub fn new() -> DamageEffect {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "aspect",
            |m: &DamageEffect| { &m.aspect },
            |m: &mut DamageEffect| { &mut m.aspect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::fraction::Fraction>(
            "scaling",
            |m: &DamageEffect| { &m.scaling },
            |m: &mut DamageEffect| { &mut m.scaling },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DamageEffect>(
            "DamageEffect",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for DamageEffect {
    fn is_initialized(&self) -> bool {
        for v in &self.scaling {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.aspect = is.read_enum_or_unknown()?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.scaling)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.aspect != ::protobuf::ProtobufEnumOrUnknown::new(super::aspect::Aspect::ASPECT_NONE) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, self.aspect);
        }
        if let Some(v) = self.scaling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.aspect != ::protobuf::ProtobufEnumOrUnknown::new(super::aspect::Aspect::ASPECT_NONE) {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&self.aspect))?;
        }
        if let Some(v) = self.scaling.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> DamageEffect {
        DamageEffect::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static DamageEffect {
        static instance: DamageEffect = DamageEffect {
            aspect: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            scaling: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for DamageEffect {
    fn clear(&mut self) {
        self.aspect = ::protobuf::ProtobufEnumOrUnknown::new(super::aspect::Aspect::ASPECT_NONE);
        self.scaling.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DamageEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DamageEffect {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct DamageOverTimeEffect {
    // message fields
    pub aspect: ::protobuf::ProtobufEnumOrUnknown<super::aspect::Aspect>,
    pub scaling: ::protobuf::MessageField<super::fraction::Fraction>,
    // message oneof groups
    pub lifetime: ::std::option::Option<damage_over_time_effect::Lifetime>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a DamageOverTimeEffect {
    fn default() -> &'a DamageOverTimeEffect {
        <DamageOverTimeEffect as ::protobuf::Message>::default_instance()
    }
}

impl DamageOverTimeEffect {
    pub fn new() -> DamageOverTimeEffect {
        ::std::default::Default::default()
    }

    // uint32 lifetime_duration = 3;

    pub fn get_lifetime_duration(&self) -> u32 {
        match self.lifetime {
            ::std::option::Option::Some(damage_over_time_effect::Lifetime::lifetime_duration(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_lifetime_duration(&mut self) {
        self.lifetime = ::std::option::Option::None;
    }

    pub fn has_lifetime_duration(&self) -> bool {
        match self.lifetime {
            ::std::option::Option::Some(damage_over_time_effect::Lifetime::lifetime_duration(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_lifetime_duration(&mut self, v: u32) {
        self.lifetime = ::std::option::Option::Some(damage_over_time_effect::Lifetime::lifetime_duration(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "aspect",
            |m: &DamageOverTimeEffect| { &m.aspect },
            |m: &mut DamageOverTimeEffect| { &mut m.aspect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::fraction::Fraction>(
            "scaling",
            |m: &DamageOverTimeEffect| { &m.scaling },
            |m: &mut DamageOverTimeEffect| { &mut m.scaling },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "lifetime_duration",
            DamageOverTimeEffect::has_lifetime_duration,
            DamageOverTimeEffect::get_lifetime_duration,
            DamageOverTimeEffect::set_lifetime_duration,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DamageOverTimeEffect>(
            "DamageOverTimeEffect",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for DamageOverTimeEffect {
    fn is_initialized(&self) -> bool {
        for v in &self.scaling {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.aspect = is.read_enum_or_unknown()?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.scaling)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lifetime = ::std::option::Option::Some(damage_over_time_effect::Lifetime::lifetime_duration(is.read_uint32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.aspect != ::protobuf::ProtobufEnumOrUnknown::new(super::aspect::Aspect::ASPECT_NONE) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, self.aspect);
        }
        if let Some(v) = self.scaling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.lifetime {
            match v {
                &damage_over_time_effect::Lifetime::lifetime_duration(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.aspect != ::protobuf::ProtobufEnumOrUnknown::new(super::aspect::Aspect::ASPECT_NONE) {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&self.aspect))?;
        }
        if let Some(v) = self.scaling.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.lifetime {
            match v {
                &damage_over_time_effect::Lifetime::lifetime_duration(v) => {
                    os.write_uint32(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> DamageOverTimeEffect {
        DamageOverTimeEffect::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static DamageOverTimeEffect {
        static instance: DamageOverTimeEffect = DamageOverTimeEffect {
            aspect: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            scaling: ::protobuf::MessageField::none(),
            lifetime: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for DamageOverTimeEffect {
    fn clear(&mut self) {
        self.aspect = ::protobuf::ProtobufEnumOrUnknown::new(super::aspect::Aspect::ASPECT_NONE);
        self.scaling.clear();
        self.lifetime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DamageOverTimeEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DamageOverTimeEffect {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DamageOverTimeEffect`
pub mod damage_over_time_effect {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Lifetime {
        lifetime_duration(u32),
    }

    impl ::protobuf::Oneof for Lifetime {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifierEffect {
    // message fields
    pub modifier: ::protobuf::MessageField<super::modifier::Modifier>,
    pub attribute: ::protobuf::ProtobufEnumOrUnknown<super::attribute::Attribute>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifierEffect {
    fn default() -> &'a ModifierEffect {
        <ModifierEffect as ::protobuf::Message>::default_instance()
    }
}

impl ModifierEffect {
    pub fn new() -> ModifierEffect {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::modifier::Modifier>(
            "modifier",
            |m: &ModifierEffect| { &m.modifier },
            |m: &mut ModifierEffect| { &mut m.modifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attribute",
            |m: &ModifierEffect| { &m.attribute },
            |m: &mut ModifierEffect| { &mut m.attribute },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModifierEffect>(
            "ModifierEffect",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for ModifierEffect {
    fn is_initialized(&self) -> bool {
        for v in &self.modifier {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.modifier)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.attribute = is.read_enum_or_unknown()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.modifier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.attribute != ::protobuf::ProtobufEnumOrUnknown::new(super::attribute::Attribute::ATTRIBUTE_AGILITY) {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, self.attribute);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.modifier.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.attribute != ::protobuf::ProtobufEnumOrUnknown::new(super::attribute::Attribute::ATTRIBUTE_AGILITY) {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&self.attribute))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ModifierEffect {
        ModifierEffect::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static ModifierEffect {
        static instance: ModifierEffect = ModifierEffect {
            modifier: ::protobuf::MessageField::none(),
            attribute: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ModifierEffect {
    fn clear(&mut self) {
        self.modifier.clear();
        self.attribute = ::protobuf::ProtobufEnumOrUnknown::new(super::attribute::Attribute::ATTRIBUTE_AGILITY);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifierEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifierEffect {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct SubEffect {
    // message oneof groups
    pub sub_effect: ::std::option::Option<sub_effect::Sub_effect>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubEffect {
    fn default() -> &'a SubEffect {
        <SubEffect as ::protobuf::Message>::default_instance()
    }
}

impl SubEffect {
    pub fn new() -> SubEffect {
        ::std::default::Default::default()
    }

    // .DamageEffect damage_effect = 1;

    pub fn get_damage_effect(&self) -> &DamageEffect {
        match self.sub_effect {
            ::std::option::Option::Some(sub_effect::Sub_effect::damage_effect(ref v)) => v,
            _ => <DamageEffect as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_damage_effect(&mut self) {
        self.sub_effect = ::std::option::Option::None;
    }

    pub fn has_damage_effect(&self) -> bool {
        match self.sub_effect {
            ::std::option::Option::Some(sub_effect::Sub_effect::damage_effect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_damage_effect(&mut self, v: DamageEffect) {
        self.sub_effect = ::std::option::Option::Some(sub_effect::Sub_effect::damage_effect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_damage_effect(&mut self) -> &mut DamageEffect {
        if let ::std::option::Option::Some(sub_effect::Sub_effect::damage_effect(_)) = self.sub_effect {
        } else {
            self.sub_effect = ::std::option::Option::Some(sub_effect::Sub_effect::damage_effect(DamageEffect::new()));
        }
        match self.sub_effect {
            ::std::option::Option::Some(sub_effect::Sub_effect::damage_effect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_damage_effect(&mut self) -> DamageEffect {
        if self.has_damage_effect() {
            match self.sub_effect.take() {
                ::std::option::Option::Some(sub_effect::Sub_effect::damage_effect(v)) => v,
                _ => panic!(),
            }
        } else {
            DamageEffect::new()
        }
    }

    // .DamageOverTimeEffect dot_effect = 2;

    pub fn get_dot_effect(&self) -> &DamageOverTimeEffect {
        match self.sub_effect {
            ::std::option::Option::Some(sub_effect::Sub_effect::dot_effect(ref v)) => v,
            _ => <DamageOverTimeEffect as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_dot_effect(&mut self) {
        self.sub_effect = ::std::option::Option::None;
    }

    pub fn has_dot_effect(&self) -> bool {
        match self.sub_effect {
            ::std::option::Option::Some(sub_effect::Sub_effect::dot_effect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dot_effect(&mut self, v: DamageOverTimeEffect) {
        self.sub_effect = ::std::option::Option::Some(sub_effect::Sub_effect::dot_effect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dot_effect(&mut self) -> &mut DamageOverTimeEffect {
        if let ::std::option::Option::Some(sub_effect::Sub_effect::dot_effect(_)) = self.sub_effect {
        } else {
            self.sub_effect = ::std::option::Option::Some(sub_effect::Sub_effect::dot_effect(DamageOverTimeEffect::new()));
        }
        match self.sub_effect {
            ::std::option::Option::Some(sub_effect::Sub_effect::dot_effect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dot_effect(&mut self) -> DamageOverTimeEffect {
        if self.has_dot_effect() {
            match self.sub_effect.take() {
                ::std::option::Option::Some(sub_effect::Sub_effect::dot_effect(v)) => v,
                _ => panic!(),
            }
        } else {
            DamageOverTimeEffect::new()
        }
    }

    // .ModifierEffect modifier_effect = 3;

    pub fn get_modifier_effect(&self) -> &ModifierEffect {
        match self.sub_effect {
            ::std::option::Option::Some(sub_effect::Sub_effect::modifier_effect(ref v)) => v,
            _ => <ModifierEffect as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_modifier_effect(&mut self) {
        self.sub_effect = ::std::option::Option::None;
    }

    pub fn has_modifier_effect(&self) -> bool {
        match self.sub_effect {
            ::std::option::Option::Some(sub_effect::Sub_effect::modifier_effect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_modifier_effect(&mut self, v: ModifierEffect) {
        self.sub_effect = ::std::option::Option::Some(sub_effect::Sub_effect::modifier_effect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_modifier_effect(&mut self) -> &mut ModifierEffect {
        if let ::std::option::Option::Some(sub_effect::Sub_effect::modifier_effect(_)) = self.sub_effect {
        } else {
            self.sub_effect = ::std::option::Option::Some(sub_effect::Sub_effect::modifier_effect(ModifierEffect::new()));
        }
        match self.sub_effect {
            ::std::option::Option::Some(sub_effect::Sub_effect::modifier_effect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_modifier_effect(&mut self) -> ModifierEffect {
        if self.has_modifier_effect() {
            match self.sub_effect.take() {
                ::std::option::Option::Some(sub_effect::Sub_effect::modifier_effect(v)) => v,
                _ => panic!(),
            }
        } else {
            ModifierEffect::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DamageEffect>(
            "damage_effect",
            SubEffect::has_damage_effect,
            SubEffect::get_damage_effect,
            SubEffect::mut_damage_effect,
            SubEffect::set_damage_effect,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DamageOverTimeEffect>(
            "dot_effect",
            SubEffect::has_dot_effect,
            SubEffect::get_dot_effect,
            SubEffect::mut_dot_effect,
            SubEffect::set_dot_effect,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ModifierEffect>(
            "modifier_effect",
            SubEffect::has_modifier_effect,
            SubEffect::get_modifier_effect,
            SubEffect::mut_modifier_effect,
            SubEffect::set_modifier_effect,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubEffect>(
            "SubEffect",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for SubEffect {
    fn is_initialized(&self) -> bool {
        if let Some(sub_effect::Sub_effect::damage_effect(ref v)) = self.sub_effect {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(sub_effect::Sub_effect::dot_effect(ref v)) = self.sub_effect {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(sub_effect::Sub_effect::modifier_effect(ref v)) = self.sub_effect {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_effect = ::std::option::Option::Some(sub_effect::Sub_effect::damage_effect(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_effect = ::std::option::Option::Some(sub_effect::Sub_effect::dot_effect(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_effect = ::std::option::Option::Some(sub_effect::Sub_effect::modifier_effect(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.sub_effect {
            match v {
                &sub_effect::Sub_effect::damage_effect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &sub_effect::Sub_effect::dot_effect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &sub_effect::Sub_effect::modifier_effect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.sub_effect {
            match v {
                &sub_effect::Sub_effect::damage_effect(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &sub_effect::Sub_effect::dot_effect(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &sub_effect::Sub_effect::modifier_effect(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SubEffect {
        SubEffect::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 3)
    }

    fn default_instance() -> &'static SubEffect {
        static instance: SubEffect = SubEffect {
            sub_effect: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SubEffect {
    fn clear(&mut self) {
        self.sub_effect = ::std::option::Option::None;
        self.sub_effect = ::std::option::Option::None;
        self.sub_effect = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubEffect {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SubEffect`
pub mod sub_effect {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Sub_effect {
        damage_effect(super::DamageEffect),
        dot_effect(super::DamageOverTimeEffect),
        modifier_effect(super::ModifierEffect),
    }

    impl ::protobuf::Oneof for Sub_effect {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TargetFlag {
    // message oneof groups
    pub target_flag: ::std::option::Option<target_flag::Target_flag>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a TargetFlag {
    fn default() -> &'a TargetFlag {
        <TargetFlag as ::protobuf::Message>::default_instance()
    }
}

impl TargetFlag {
    pub fn new() -> TargetFlag {
        ::std::default::Default::default()
    }

    // bool any = 1;

    pub fn get_any(&self) -> bool {
        match self.target_flag {
            ::std::option::Option::Some(target_flag::Target_flag::any(v)) => v,
            _ => false,
        }
    }

    pub fn clear_any(&mut self) {
        self.target_flag = ::std::option::Option::None;
    }

    pub fn has_any(&self) -> bool {
        match self.target_flag {
            ::std::option::Option::Some(target_flag::Target_flag::any(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_any(&mut self, v: bool) {
        self.target_flag = ::std::option::Option::Some(target_flag::Target_flag::any(v))
    }

    // .Gender gender = 2;

    pub fn get_gender(&self) -> super::gender::Gender {
        match self.target_flag {
            ::std::option::Option::Some(target_flag::Target_flag::gender(v)) => ::protobuf::ProtobufEnumOrUnknown::enum_value_or_default(&v),
            _ => super::gender::Gender::GENDER_NONE,
        }
    }

    pub fn clear_gender(&mut self) {
        self.target_flag = ::std::option::Option::None;
    }

    pub fn has_gender(&self) -> bool {
        match self.target_flag {
            ::std::option::Option::Some(target_flag::Target_flag::gender(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gender(&mut self, v: super::gender::Gender) {
        self.target_flag = ::std::option::Option::Some(target_flag::Target_flag::gender(::protobuf::ProtobufEnumOrUnknown::new(v)))
    }

    // bool origin = 3;

    pub fn get_origin(&self) -> bool {
        match self.target_flag {
            ::std::option::Option::Some(target_flag::Target_flag::origin(v)) => v,
            _ => false,
        }
    }

    pub fn clear_origin(&mut self) {
        self.target_flag = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        match self.target_flag {
            ::std::option::Option::Some(target_flag::Target_flag::origin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: bool) {
        self.target_flag = ::std::option::Option::Some(target_flag::Target_flag::origin(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "any",
            TargetFlag::has_any,
            TargetFlag::get_any,
            TargetFlag::set_any,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "gender",
            TargetFlag::has_gender,
            TargetFlag::get_gender,
            TargetFlag::set_gender,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "origin",
            TargetFlag::has_origin,
            TargetFlag::get_origin,
            TargetFlag::set_origin,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TargetFlag>(
            "TargetFlag",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for TargetFlag {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_flag = ::std::option::Option::Some(target_flag::Target_flag::any(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_flag = ::std::option::Option::Some(target_flag::Target_flag::gender(is.read_enum_or_unknown()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_flag = ::std::option::Option::Some(target_flag::Target_flag::origin(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.target_flag {
            match v {
                &target_flag::Target_flag::any(v) => {
                    my_size += 2;
                },
                &target_flag::Target_flag::gender(v) => {
                    my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
                },
                &target_flag::Target_flag::origin(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.target_flag {
            match v {
                &target_flag::Target_flag::any(v) => {
                    os.write_bool(1, v)?;
                },
                &target_flag::Target_flag::gender(v) => {
                    os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
                },
                &target_flag::Target_flag::origin(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> TargetFlag {
        TargetFlag::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static TargetFlag {
        static instance: TargetFlag = TargetFlag {
            target_flag: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for TargetFlag {
    fn clear(&mut self) {
        self.target_flag = ::std::option::Option::None;
        self.target_flag = ::std::option::Option::None;
        self.target_flag = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TargetFlag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TargetFlag {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TargetFlag`
pub mod target_flag {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Target_flag {
        any(bool),
        gender(::protobuf::ProtobufEnumOrUnknown<super::super::gender::Gender>),
        origin(bool),
    }

    impl ::protobuf::Oneof for Target_flag {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TargetQuery {
    // message fields
    pub target_flags: ::std::vec::Vec<TargetFlag>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a TargetQuery {
    fn default() -> &'a TargetQuery {
        <TargetQuery as ::protobuf::Message>::default_instance()
    }
}

impl TargetQuery {
    pub fn new() -> TargetQuery {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "target_flags",
            |m: &TargetQuery| { &m.target_flags },
            |m: &mut TargetQuery| { &mut m.target_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TargetQuery>(
            "TargetQuery",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for TargetQuery {
    fn is_initialized(&self) -> bool {
        for v in &self.target_flags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.target_flags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.target_flags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.target_flags {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> TargetQuery {
        TargetQuery::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static TargetQuery {
        static instance: TargetQuery = TargetQuery {
            target_flags: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for TargetQuery {
    fn clear(&mut self) {
        self.target_flags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TargetQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TargetQuery {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct TargetingScheme {
    // message oneof groups
    pub targeting_scheme: ::std::option::Option<targeting_scheme::Targeting_scheme>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a TargetingScheme {
    fn default() -> &'a TargetingScheme {
        <TargetingScheme as ::protobuf::Message>::default_instance()
    }
}

impl TargetingScheme {
    pub fn new() -> TargetingScheme {
        ::std::default::Default::default()
    }

    // bool all = 1;

    pub fn get_all(&self) -> bool {
        match self.targeting_scheme {
            ::std::option::Option::Some(targeting_scheme::Targeting_scheme::all(v)) => v,
            _ => false,
        }
    }

    pub fn clear_all(&mut self) {
        self.targeting_scheme = ::std::option::Option::None;
    }

    pub fn has_all(&self) -> bool {
        match self.targeting_scheme {
            ::std::option::Option::Some(targeting_scheme::Targeting_scheme::all(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.targeting_scheme = ::std::option::Option::Some(targeting_scheme::Targeting_scheme::all(v))
    }

    // uint32 multi_target = 2;

    pub fn get_multi_target(&self) -> u32 {
        match self.targeting_scheme {
            ::std::option::Option::Some(targeting_scheme::Targeting_scheme::multi_target(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_multi_target(&mut self) {
        self.targeting_scheme = ::std::option::Option::None;
    }

    pub fn has_multi_target(&self) -> bool {
        match self.targeting_scheme {
            ::std::option::Option::Some(targeting_scheme::Targeting_scheme::multi_target(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_target(&mut self, v: u32) {
        self.targeting_scheme = ::std::option::Option::Some(targeting_scheme::Targeting_scheme::multi_target(v))
    }

    // bool single_target = 3;

    pub fn get_single_target(&self) -> bool {
        match self.targeting_scheme {
            ::std::option::Option::Some(targeting_scheme::Targeting_scheme::single_target(v)) => v,
            _ => false,
        }
    }

    pub fn clear_single_target(&mut self) {
        self.targeting_scheme = ::std::option::Option::None;
    }

    pub fn has_single_target(&self) -> bool {
        match self.targeting_scheme {
            ::std::option::Option::Some(targeting_scheme::Targeting_scheme::single_target(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single_target(&mut self, v: bool) {
        self.targeting_scheme = ::std::option::Option::Some(targeting_scheme::Targeting_scheme::single_target(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "all",
            TargetingScheme::has_all,
            TargetingScheme::get_all,
            TargetingScheme::set_all,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "multi_target",
            TargetingScheme::has_multi_target,
            TargetingScheme::get_multi_target,
            TargetingScheme::set_multi_target,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "single_target",
            TargetingScheme::has_single_target,
            TargetingScheme::get_single_target,
            TargetingScheme::set_single_target,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TargetingScheme>(
            "TargetingScheme",
            6,
            fields,
        )
    }
}

impl ::protobuf::Message for TargetingScheme {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.targeting_scheme = ::std::option::Option::Some(targeting_scheme::Targeting_scheme::all(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.targeting_scheme = ::std::option::Option::Some(targeting_scheme::Targeting_scheme::multi_target(is.read_uint32()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.targeting_scheme = ::std::option::Option::Some(targeting_scheme::Targeting_scheme::single_target(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.targeting_scheme {
            match v {
                &targeting_scheme::Targeting_scheme::all(v) => {
                    my_size += 2;
                },
                &targeting_scheme::Targeting_scheme::multi_target(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &targeting_scheme::Targeting_scheme::single_target(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.targeting_scheme {
            match v {
                &targeting_scheme::Targeting_scheme::all(v) => {
                    os.write_bool(1, v)?;
                },
                &targeting_scheme::Targeting_scheme::multi_target(v) => {
                    os.write_uint32(2, v)?;
                },
                &targeting_scheme::Targeting_scheme::single_target(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> TargetingScheme {
        TargetingScheme::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 6)
    }

    fn default_instance() -> &'static TargetingScheme {
        static instance: TargetingScheme = TargetingScheme {
            targeting_scheme: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for TargetingScheme {
    fn clear(&mut self) {
        self.targeting_scheme = ::std::option::Option::None;
        self.targeting_scheme = ::std::option::Option::None;
        self.targeting_scheme = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TargetingScheme {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TargetingScheme {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TargetingScheme`
pub mod targeting_scheme {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Targeting_scheme {
        all(bool),
        multi_target(u32),
        single_target(bool),
    }

    impl ::protobuf::Oneof for Targeting_scheme {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Effect {
    // message fields
    pub sub_effects: ::std::vec::Vec<SubEffect>,
    pub target_queries: ::std::vec::Vec<TargetQuery>,
    pub targeting_scheme: ::protobuf::MessageField<TargetingScheme>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Effect {
    fn default() -> &'a Effect {
        <Effect as ::protobuf::Message>::default_instance()
    }
}

impl Effect {
    pub fn new() -> Effect {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sub_effects",
            |m: &Effect| { &m.sub_effects },
            |m: &mut Effect| { &mut m.sub_effects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "target_queries",
            |m: &Effect| { &m.target_queries },
            |m: &mut Effect| { &mut m.target_queries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TargetingScheme>(
            "targeting_scheme",
            |m: &Effect| { &m.targeting_scheme },
            |m: &mut Effect| { &mut m.targeting_scheme },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Effect>(
            "Effect",
            7,
            fields,
        )
    }
}

impl ::protobuf::Message for Effect {
    fn is_initialized(&self) -> bool {
        for v in &self.sub_effects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.target_queries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.targeting_scheme {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.sub_effects)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.target_queries)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.targeting_scheme)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sub_effects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.target_queries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.targeting_scheme.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sub_effects {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.target_queries {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.targeting_scheme.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Effect {
        Effect::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 7)
    }

    fn default_instance() -> &'static Effect {
        static instance: Effect = Effect {
            sub_effects: ::std::vec::Vec::new(),
            target_queries: ::std::vec::Vec::new(),
            targeting_scheme: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Effect {
    fn clear(&mut self) {
        self.sub_effects.clear();
        self.target_queries.clear();
        self.targeting_scheme.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Effect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Effect {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ceffect.proto\x1a\x0caspect.proto\x1a\x0fattribute.proto\x1a\x0efra\
    ction.proto\x1a\x0cgender.proto\x1a\x0emodifier.proto\"T\n\x0cDamageEffe\
    ct\x12\x1f\n\x06aspect\x18\x01\x20\x01(\x0e2\x07.AspectR\x06aspect\x12#\
    \n\x07scaling\x18\x02\x20\x01(\x0b2\t.FractionR\x07scaling\"\x97\x01\n\
    \x14DamageOverTimeEffect\x12\x1f\n\x06aspect\x18\x01\x20\x01(\x0e2\x07.A\
    spectR\x06aspect\x12#\n\x07scaling\x18\x02\x20\x01(\x0b2\t.FractionR\x07\
    scaling\x12-\n\x11lifetime_duration\x18\x03\x20\x01(\rH\0R\x10lifetimeDu\
    rationB\n\n\x08lifetime\"a\n\x0eModifierEffect\x12%\n\x08modifier\x18\
    \x01\x20\x01(\x0b2\t.ModifierR\x08modifier\x12(\n\tattribute\x18\x02\x20\
    \x01(\x0e2\n.AttributeR\tattribute\"\xc3\x01\n\tSubEffect\x124\n\rdamage\
    _effect\x18\x01\x20\x01(\x0b2\r.DamageEffectH\0R\x0cdamageEffect\x126\n\
    \ndot_effect\x18\x02\x20\x01(\x0b2\x15.DamageOverTimeEffectH\0R\tdotEffe\
    ct\x12:\n\x0fmodifier_effect\x18\x03\x20\x01(\x0b2\x0f.ModifierEffectH\0\
    R\x0emodifierEffectB\x0c\n\nsub_effect\"l\n\nTargetFlag\x12\x12\n\x03any\
    \x18\x01\x20\x01(\x08H\0R\x03any\x12!\n\x06gender\x18\x02\x20\x01(\x0e2\
    \x07.GenderH\0R\x06gender\x12\x18\n\x06origin\x18\x03\x20\x01(\x08H\0R\
    \x06originB\r\n\x0btarget_flag\"=\n\x0bTargetQuery\x12.\n\x0ctarget_flag\
    s\x18\x01\x20\x03(\x0b2\x0b.TargetFlagR\x0btargetFlags\"\x85\x01\n\x0fTa\
    rgetingScheme\x12\x12\n\x03all\x18\x01\x20\x01(\x08H\0R\x03all\x12#\n\
    \x0cmulti_target\x18\x02\x20\x01(\rH\0R\x0bmultiTarget\x12%\n\rsingle_ta\
    rget\x18\x03\x20\x01(\x08H\0R\x0csingleTargetB\x12\n\x10targeting_scheme\
    \"\xa7\x01\n\x06Effect\x12+\n\x0bsub_effects\x18\x01\x20\x03(\x0b2\n.Sub\
    EffectR\nsubEffects\x123\n\x0etarget_queries\x18\x02\x20\x03(\x0b2\x0c.T\
    argetQueryR\rtargetQueries\x12;\n\x10targeting_scheme\x18\x03\x20\x01(\
    \x0b2\x10.TargetingSchemeR\x0ftargetingSchemeb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        deps.push(super::aspect::file_descriptor());
        deps.push(super::attribute::file_descriptor());
        deps.push(super::fraction::file_descriptor());
        deps.push(super::gender::file_descriptor());
        deps.push(super::modifier::file_descriptor());
        let mut messages = ::std::vec::Vec::new();
        messages.push(DamageEffect::generated_message_descriptor_data());
        messages.push(DamageOverTimeEffect::generated_message_descriptor_data());
        messages.push(ModifierEffect::generated_message_descriptor_data());
        messages.push(SubEffect::generated_message_descriptor_data());
        messages.push(TargetFlag::generated_message_descriptor_data());
        messages.push(TargetQuery::generated_message_descriptor_data());
        messages.push(TargetingScheme::generated_message_descriptor_data());
        messages.push(Effect::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
